\documentclass[11pt,twocolumn,a4paper]{article}
\usepackage[top=1.4cm,bottom=1cm,left=1cm,right=1cm]{geometry}
												%設定留白
\usepackage{fontspec}							%設定字體
\usepackage{color}
\usepackage{xeCJK}								%xeCJK
\usepackage{listings}							%顯示code用的
\usepackage[Sonny]{fncychap}					%排版，頁面模板
\usepackage{fancyhdr}							%設定頁首頁尾
\usepackage[compact]{titlesec}  				%tielespacing
\usepackage{enumerate}							%ordered item
\usepackage[bookmarks,hidelinks]{hyperref}		%make bookmarks

%\topmargin=0pt
\headsep=5pt
%\textheight=750pt
\footskip=20pt
\columnsep=5pt									%兩欄間隔
%\voffset=-40pt
%\textwidth=520pt
%\marginparsep=0pt
%\marginparwidth=0pt
%\marginparpush=0pt
%\oddsidemargin=0pt
%\evensidemargin=0pt
%\hoffset=-30pt

\title{Codebook v1.4 Alpha}
\author{kevinptt}
\date{Sep 27, 2014}
\setmainfont{Perpetua}							%主要字型
\setmonofont{Consolas}							%等寬字型
\setCJKmainfont{文泉驛微米黑}					%中文字型
\XeTeXlinebreaklocale "zh"						%中文自動換行
\titleformat{\section}{\normalfont\LARGE\bfseries}{\thesection}{1em}{}
\titlespacing{\section}{0pt}{0pt}{0pt}
\titlespacing{\subsection}{0pt}{0pt}{0pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset{										% Code顯示
language=C++,									% the language of the code
basicstyle=\footnotesize\ttfamily, 				% the size of the fonts that are used for the code
numbers=none,									% where to put the line-numbers
numberstyle=\ttfamily,							% the size of the fonts that are used for the line-numbers
stepnumber=1,									% the step between two line-numbers. If it's 1, each line will be numbered
numbersep=8pt,									% how far the line-numbers are from the code
backgroundcolor=\color{white},					% choose the background color. You must add \usepackage{color}
showspaces=false,								% show spaces adding particular underscores
showstringspaces=false,							% underline spaces within strings
showtabs=false,									% show tabs within strings adding particular underscores
frame=no,										% adds a frame around the code
tabsize=2,										% sets default tabsize to 2 spaces
captionpos=b,									% sets the caption-position to bottom
breaklines=true,								% sets automatic line breaking
breakatwhitespace=false,						% sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},							% if you want to add a comment within your code
morekeywords={*}								% if you want to add more keywords to the set
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%\pagestyle{fancy}
%\fancyfoot{}
%\fancyhead{}
%\fancyhead[R]{\thepage}
%\renewcommand{\headrulewidth}{0.4pt}
%\renewcommand{\footrulewidth}{0pt}
\renewcommand{\contentsname}{Index}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Enviroment Settings}
\subsection{.vimrc}
\begin{lstlisting}[label=.vimrc,language=bash]
" set encoding
set encoding=utf-8
set fileencodings=utf-8,big5
set showmode
syntax on
set hlsearch
set background=dark
set laststatus=2
set wildmenu
set scrolloff=5 " keep at least 5 lines above/below
set ruler
set cursorline
set ic    " ignore case when searching
set bs=2  " enable backspace
set number
set tabstop=4
set shiftwidth=4
set autoindent
set smarttab
set smartindent
""""""" abbr
syntax on
set enc=utf-8 fencs=utf-8,big5
set bs=2
set smd nu bg=dark hls ls=2 wmnu so=5 ru cul
set ts=4 sw=4 ai sta si
set list lcs=tab:>\  "# a space after '\'
imap<F9> <ESC>:w<Enter><F9>
map<F9> :!g++ "%:t" -o "%:r.out" -Wall -Wshadow -O2 -Im && "./%:r.out"
map<F10> :!g++ "%:t" -o "%:r.out" -Wall -Wshadow -O2 -Im
autocmd! BufNewFile * silent! 0r ~/.vim/skel/Template.%:e
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Computational Geometry}

\subsection{Geometry on Plane}
\lstinputlisting{code/Geometry_on_Plane.cpp}

\subsection{KDTree}
\lstinputlisting{code/KDTree.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Data Structure}

\subsection{BigInteger}
\lstinputlisting{code/BigInteger.cpp}

\subsection{Fenwick Tree Range Modify [1, size]}
\lstinputlisting{code/BIT_range_modify.cpp}

\subsection{Fenwick Tree 2D - [1, size][1, size]}
\lstinputlisting{code/BIT_2D.cpp}

\subsection{Splay Tree}
\lstinputlisting{code/splay.cpp}

\subsection{Treap}
\lstinputlisting{code/treap.cpp}

\subsection{劃分樹}
\begin{lstlisting}[label=劃分樹]
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define N 100005
int a[N], as[N];//原數組，排序後數組 
int n, m;
int sum[20][N];//紀錄第i層的1~j劃分到左子樹的元素個數(包括j)
int tree[20][N];//紀錄第i層元素序列
void build(int c, int l, int r) {
	int i, mid=(l+r)>>1, lm=mid-l+1, lp=l, rp=mid+1;
	for (i=l; i<=mid; i++)
		if (as[i] < as[mid]) lm--;
			//先假設左邊的(mid-l+1)個數都等于as[mid],然后把實際上小于as[mid]的減去
	for (i = l; i <= r; i++){
		if (i == l) sum[c][i] = 0;
			//sum[i]表示[l, i]內有多少個數分到左邊，用DP來維護 
		else sum[c][i] = sum[c][i-1];
		if (tree[c][i] == as[mid]){
			if (lm){
				lm--;
				sum[c][i]++;
				tree[c+1][lp++] = tree[c][i];
			}else
				tree[c+1][rp++] = tree[c][i];
		} else if (tree[c][i] < as[mid]){
			sum[c][i]++;
			tree[c+1][lp++] = tree[c][i];
		} else
			tree[c+1][rp++] = tree[c][i];
	}
	if (l == r)return;
	build(c+1, l, mid);
	build(c+1, mid+1, r);
}
int query(int c, int l, int r, int ql, int qr, int k){
	int s;//[l, ql)內將被劃分到左子樹的元素數目
	int ss;//[ql, qr]內將被劃分到左子數的元素數目
	int mid=(l+r)>>1;
	if (l == r)
		return tree[c][l];
	if (l == ql){//這裡要特殊處理！
		s = 0;
		ss = sum[c][qr];
	}else{
		s = sum[c][ql 1];
		ss = sum[c][qr]- ;
	} //假設要在區間[l,r]中查找第k大元素，t為當前節點，lch，rch為左右孩子，left，mid為節點t左邊界界和中間點。
	if (k <= ss)//sum[r]-sum[l-1]>=k，查找lch[t],區間對應為[ left+sum[l-1], left+sum[r]-1 ]
		return query(c+1, l, mid, l+s, l+s+ss-1, k);
	else
		//sum[r]-sum[l-1]<k,查找rch[t]，區間對應為
		[mid+1+l-left-sum[l-1], mid+1+r-left-sum[r]]
		return query(c+1, mid+1, r, mid-l+1+ql-s, mid-l+1+qr-s-ss, k-ss);
}
int main(){
	int i, j, k;
	while(~scanf("%d%d", &n, &m)){
		for(i=1; i<=n; i++) {
			scanf("%d", &a[i]);
			tree[0][i] = as[i] = a[i];
		}
		sort(as+1, as+1+n);
		build(0, 1, n);
		while(m--){
			scanf("%d%d%d", &i, &j, &k);
				// i,j分別為區間起始點，k為該區間第k大的數。
			printf("%d\n", query(0, 1, n, i, j, k));
		}
	}
	return 0;
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Graph}
\subsection{Dinic}
\lstinputlisting{code/dinic.cpp}

\subsection{maximum matching in general graph}
\begin{lstlisting}[label=maximum matching in general graph]
//Problem:http://acm.timus.ru/problem.aspx?space=1&num=1099
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N=250;
int n;
int head;
int tail;
int Start;
int Finish;
int link[N];		//表示哪個點匹配了哪個點
int Father[N];		//這個就是增廣路的Father……但是用起來太精髓了
int Base[N];		//該點屬於哪朵花
int Q[N];
bool mark[N];
bool map[N][N];
bool InBlossom[N];
bool in_Queue[N];
 
void CreateGraph(){
	int x,y;
	scanf("%d",&n);
	while (scanf("%d%d",&x,&y)!=EOF)
		map[x][y]=map[y][x]=1;
}
void BlossomContract(int x,int y){
	fill(mark,mark+n+1,false);
	fill(InBlossom,InBlossom+n+1,false);
	#define pre Father[link[i]]
	int lca,i;
	for (i=x;i;i=pre) {i=Base[i]; mark[i]=true; }
	for (i=y;i;i=pre) {i=Base[i]; if (mark[i]) {lca=i; break;} }  //尋找lca之旅……一定要注意i=Base[i]
	for (i=x;Base[i]!=lca;i=pre){
		if (Base[pre]!=lca) Father[pre]=link[i]; //對於BFS樹中的父邊是匹配邊的點，Father向後跳
		InBlossom[Base[i]]=true;
		InBlossom[Base[link[i]]]=true;
	}
	for (i=y;Base[i]!=lca;i=pre){
		if (Base[pre]!=lca) Father[pre]=link[i]; //同理
		InBlossom[Base[i]]=true;
		InBlossom[Base[link[i]]]=true;
	}
	#undef pre
	if (Base[x]!=lca) Father[x]=y;	 //注意不能從lca這個奇環的關鍵點跳回來
	if (Base[y]!=lca) Father[y]=x;
	for (i=1;i<=n;i++)
	  if (InBlossom[Base[i]]){
			Base[i]=lca;
			if (!in_Queue[i]){
				Q[++tail]=i;
				in_Queue[i]=true;	 //要注意如果本來連向BFS樹中父結點的邊是非匹配邊的點，可能是沒有入隊的
		  }
	  }
}
void Change(){
	int x,y,z;
	z=Finish;
	while (z){
		y=Father[z];
		x=link[y];
		link[y]=z;
		link[z]=y;
		z=x;
	}
}
void FindAugmentPath(){
	fill(Father,Father+n+1,0);
	fill(in_Queue,in_Queue+n+1,false);
	for (int i=1;i<=n;i++) Base[i]=i;
	head=0; tail=1;
	Q[1]=Start;
	in_Queue[Start]=1;
	while (head!=tail){
		int x=Q[++head];
		for (int y=1;y<=n;y++)
			if (map[x][y] && Base[x]!=Base[y] && link[x]!=y)   //無意義的邊
				if ( Start==y || link[y] && Father[link[y]] )	//精髓地用Father表示該點是否
					BlossomContract(x,y);
				else if (!Father[y]){
					Father[y]=x;
					if (link[y]){
						Q[++tail]=link[y];
						in_Queue[link[y]]=true;
					}
					else{
						Finish=y;
						Change();
						return;
					}
				}
	}
}
void Edmonds(){
	memset(link,0,sizeof(link));
	for (Start=1;Start<=n;Start++)
		if (link[Start]==0)
			FindAugmentPath();
}
void output(){
	fill(mark,mark+n+1,false);
	int cnt=0;
	for (int i=1;i<=n;i++)
		if (link[i]) cnt++;
	printf("%d\n",cnt);
	for (int i=1;i<=n;i++)
		if (!mark[i] && link[i]){
			mark[i]=true;
			mark[link[i]]=true;
			printf("%d %d\n",i,link[i]);
		}
}
int main(){
	CreateGraph();
	Edmonds();
	output();
	return 0;
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Math}
\subsection{China remainder theorem}
$ ans \equiv  a_i\; (mod\; m_i) $
\lstinputlisting{code/CRT.cpp}

\subsection{Euler's phi function O(n)}
\begin{enumerate}[1.]
\item $gcd(x,y)=d \Rightarrow \phi(xy) = \frac{\phi(x) \phi(y)}{\phi(d)}$
\item $p\; is\; prime \Rightarrow \phi(p^k) = p^{k-1} \phi(p)$
\item $p\; is\; prime \Rightarrow \phi(p^k) = \phi(p^{k-1}) \times p$
\item $n = p_{1}^{k_1} p_{2}^{k_2} \cdots p_{m}^{k_m}\\
\Rightarrow \phi(n) = p_{1}^{k_1-1}\phi(p_1)\; p_{2}^{k_2-1}\phi(p_2) \cdots p_{m}^{k_m-1}\phi(p_m)$
\end{enumerate}
\lstinputlisting{code/EularPhi.cpp}

\subsection{Extended Euclid's Algorithm}
$ ax+by=gcd(a,b) $
\lstinputlisting{code/ExtendedEuclid.cpp}

\subsection{Gaussian Elimination}
\lstinputlisting{code/GaussianElimination.cpp}

\subsection{Miller Rabin}
\lstinputlisting{code/Miller-Rabin.cpp}

\subsection{Möbius function}
\lstinputlisting{code/Mobius.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{String}
\subsection{AhoCorasick}
\lstinputlisting{code/AC-Automaton.cpp}

\subsection{KMP}
\lstinputlisting{code/KMP.cpp}

\subsection{Longest Palindromic Substring}
\lstinputlisting{code/LPS.cpp}

\subsection{Suffix Array}
\lstinputlisting{code/SuffixArray.cpp}

\subsection{Z Algorithm}
\lstinputlisting{code/Z-Algorithm.cpp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Others}
\subsection{8 puzzle - IDA*}
\begin{lstlisting}[label=8 puzzle - IDA*]
// 一個盤面。其數值1~8代表方塊號碼，0代表空格。
int board[3][3] = {2, 3, 4, 1, 5, 0, 7, 6, 8};
// 檢查 permutation inversion。檢查不通過，表示盤面不合理。
bool check_permutation_inversion(int board[3][3])
{
	int inversion = 0;
	for (int a=0; a<9; ++a)
		for (int b=0; b<a; ++b) {
			int i = a / 3, j = a % 3;
			int ii = b / 3, jj = b % 3;
			if (board[i][j] && board[ii][jj]
				&& board[i][j] < board[ii][jj])
				inversion++;
		}
	int row_number_of_0 = 0;
	for (int i=0; i<3 && !row_number_of_0; ++i)
		for (int j=0; j<3 && !row_number_of_0; ++j)
			if (board[i][j] == 0)
				row_number_of_0 = i+1;
	return (inversion + row_number_of_0) % 2 == 0;
}
//////////////////////////
// heuristic function，採用不在正確位置上的方塊個數。
int h(int board[3][3])
{
	int cost = 0;
	for (int i=0; i<3; ++i)
		for (int j=0; j<3; ++j)
			if (board[i][j])
				if (board[i][j] != i*3 + j + 1)
					cost++;
	return cost;
}
//////////////////////////
int taxicab_distance(int x1, int y1, int x2, int y2)
{return abs(x1 - x2) + abs(y1 - y2);}
 
// heuristic function，採用taxicab distance。
int h(int board[3][3]) {
	// 每塊方塊的正確位置。{0,0}是為了方便編寫程式而多加的。
	static const int right_pos[9][2] = {
		{0,0},
		{0,0}, {0,1}, {0,2},
		{1,0}, {1,1}, {1,2},
		{2,0}, {2,1}
	};
	// 計算每個方塊與其正確位置的 taxicab distance 的總和。
	int cost = 0;
	for (int i=0; i<3; ++i)
		for (int j=0; j<3; ++j)
			if (board[i][j])
				cost += taxicab_distance(
							i, j,
							right_pos[board[i][j]][0],
							right_pos[board[i][j]][1]
						);
	return cost;
}

// 上下左右
const string operator[4] = {"up", "down", "right", "left"};
const int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, 1, -1};
char solution[30];
	// 正確的推動方式，其數值是方向0~3。
const int reverse_dir[4] = {1, 0, 3, 2};
	// 用表格紀錄每一個方向的反方向。可用於避免來回推動的判斷。

int board[3][3] = {2, 3, 4, 1, 5, 0, 7, 6, 8};
	// 起始狀態。其數值1~8代表方塊號碼，0代表空格。

int sx = 1, sy = 2;
	// 空格的位置。可馬上知道推動方塊的目的地。

bool onboard(int x, int y)
{return x>=0 && x<3 && y>=0 && y<3;}
 
int IDAstar(int x, int y, int gv, int prev_dir, int& bound, bool& ans) {
	int hv = h(board);
	if (gv + hv > bound) return gv + hv;
		// 超過，回傳下次的bound
	if (hv == 0) {ans = true; return gv;}
		// 找到最佳解
 
	int next_bound = 1e9;
	for (int i=0; i<4; ++i) {
		// 四種推動方向
		int nx = x + dx[i], ny = y + dy[i];
			// 空格的新位置
		if (reverse_dir[i] == prev_dir) continue;
			// 避免來回推動
		if (!onboard(nx, ny)) continue;
			// 避免出界
		solution[gv] = oper[i];
			// 紀錄推動方向
		swap(board[x][y], board[nx][ny]);
			// 推動
		int v = IDAstar(nx, ny, gv+1, i, bound, ans);
		if (ans) return v;
		next_bound = min(next_bound, v);
		swap(board[nx][ny], board[x][y]);
			// 回復原狀態
	}
	return next_bound;
}
 
void eight_puzzle() {
	if (!check_permutation_inversion(board)) {
		cout << "盤面不合理，無法解得答案。" << endl;
		return;
	}
	// IDA*
	bool ans = false;
	int bound = 0;
	while (!ans && bound <= 50)
		bound = IDAstar(sx, sy, 0, -1, bound, ans);
	if (!ans) {
		cout << "50步內無法解得答案。" << endl;
		return;
	}
	// 印出移動方法
	for (int i=0; i<bound; ++i)
		cout << operation[solution[i]] << ' ';
	cout << endl;
}
\end{lstlisting}

\subsection{recursive to stack}
replace all variable in data into layer[lay].variable
\begin{lstlisting}[label=recursive to stack]
struct data {
	parameter;
	local variabla;
	direction;		//new
} layer[10000];
int lay=0;	//new
type reval;	//new
void go() {
// at the beginning
start:
// call recursive function	
	direction = 1;
	lay++, parameter = value;
	goto start;
point1:
	variable = reval;
// return
	reval = value;
	lay--;
	goto trans;
// at the end
trans:
	switch (direction) {
		case 1:
			goto point1;
	}
}
\end{lstlisting}

\section*{The End}
\end{document}
